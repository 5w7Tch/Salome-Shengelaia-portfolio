<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <link rel="stylesheet" href="style.css" />
  <link rel="icon" type="image/png" href="salome.png" />

  <title>Salome Shengelaia Portfolio</title>
</head>

<body>
  <!-- Loading Screen -->
  <!-- <div class="loading-screen" id="loadingScreen">
    <div class="loader-container">
      <div class="loader"></div>
      <p class="loading-text">Loading Portfolio...</p>
      <p class="loading-progress" id="loadingProgress">0%</p>
    </div>
  </div> -->

  <!-- Background loading indicator -->
  <!-- <div class="bg-loading-indicator" id="bgLoadingIndicator" style="display: none;">
    <div class="bg-loader"></div>
    <span id="bgLoadingText">Loading pages...</span>
  </div> -->

  <button class="nav-arrow prev-arrow" id="prevBtn">‹</button>
  <button class="nav-arrow next-arrow" id="nextBtn">›</button>

  <div class="flipbook">
    <!-- Dynamic pages will be inserted here -->
    <div class="hard"></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="jquery.js"></script>
  <script src="turn.js"></script>
  <script>
    // Configure PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // Path to your PDF file
    const pdfPath = 'PORTFOLIOOO.pdf';
    let loadedPages = new Set();
    let totalPagesCount = 0;
    let flipbookInitialized = false;
    let isAnimating = false;
    let pdfDocument = null;
    let renderQueue = new Map(); // Track pages being rendered
    let pageCache = new Map(); // Cache rendered canvases
    const MAX_CACHE_SIZE = 10; // Maximum pages to keep in memory

    // Detect if mobile device
    const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const RENDER_QUALITY = isMobileDevice ? 1.5 : 2.5; // Lower quality on mobile for speed

    // Update loading progress
    // function updateProgress(current, total) {
    //   const percentage = Math.round((current / total) * 100);
    //   $('#loadingProgress').text(percentage + '%');
    // }

    // Hide initial loading screen
    // function hideLoadingScreen() {
    //   $('#loadingScreen').fadeOut(500, function() {
    //     $(this).remove();
    //   });
    // }

    // Update background loading indicator
    function updateBackgroundLoading(current, total) {
      if (current >= total) {
        $('#bgLoadingIndicator').fadeOut();
      } else {
        $('#bgLoadingText').text(`Loading pages... ${current}/${total}`);
      }
    }

    // Create placeholder page
    function createPlaceholderPage() {
      const pageDiv = $('<div class="page page-loading"></div>');
      pageDiv.html('<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;"><div><div class="loader" style="margin: 0 auto 20px;"></div><p>Loading page...</p></div></div>');
      return pageDiv;
    }

    // Clear old pages from cache (LRU strategy)
    function clearOldCache(currentPage) {
      if (pageCache.size > MAX_CACHE_SIZE) {
        // Keep pages around current view, remove others
        const pagesToKeep = new Set();
        for (let i = Math.max(1, currentPage - 3); i <= Math.min(totalPagesCount, currentPage + 3); i++) {
          pagesToKeep.add(i);
        }

        for (let [pageNum, canvas] of pageCache.entries()) {
          if (!pagesToKeep.has(pageNum)) {
            // Clear canvas to free memory
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            pageCache.delete(pageNum);
            console.log(`Cleared page ${pageNum} from cache`);
          }
        }
      }
    }

    // Render a single page with optimization
    async function renderPage(pdf, pageNum, pageDiv, priority = false) {
      // Check if already rendering
      if (renderQueue.has(pageNum)) {
        console.log(`Page ${pageNum} already rendering, skipping...`);
        return renderQueue.get(pageNum);
      }

      // Check cache first
      if (pageCache.has(pageNum)) {
        console.log(`Page ${pageNum} loaded from cache`);
        const cachedCanvas = pageCache.get(pageNum).cloneNode(true);
        pageDiv.empty();
        pageDiv.removeClass('page-loading');
        pageDiv.append(cachedCanvas);
        loadedPages.add(pageNum);
        // updateBackgroundLoading(loadedPages.size, totalPagesCount);
        return true;
      }

      const renderPromise = (async () => {
        try {
          const page = await pdf.getPage(pageNum);
          
          // Create canvas for this page
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d', { 
            alpha: false,
            desynchronized: true 
          });
          
          // Get the viewport at scale 1
          const viewport = page.getViewport({ scale: 1 });
          
          // Calculate device pixel ratio for retina displays
          const pixelRatio = window.devicePixelRatio || 1;
          
          // Calculate scale to fit the page
          const displayScale = Math.min(594 / viewport.width, 840 / viewport.height);
          const renderScale = displayScale * RENDER_QUALITY * (priority ? 1 : 0.8); // Slightly lower for background loads
          
          const scaledViewport = page.getViewport({ scale: renderScale });
          
          // Set canvas size
          canvas.width = scaledViewport.width;
          canvas.height = scaledViewport.height;
          
          // Set display size
          canvas.style.width = '100%';
          canvas.style.height = '100%';
          canvas.style.display = 'block';
          
          // Render PDF page with optimizations
          const renderContext = {
            canvasContext: context,
            viewport: scaledViewport,
            intent: 'display',
            renderInteractiveForms: false,
            enableWebGL: false, // Disable WebGL for better compatibility
            background: 'white'
          };

          // Use lower quality for non-priority renders
          if (!priority) {
            renderContext.intent = 'print'; // Sometimes faster
          }

          await page.render(renderContext).promise;
          
          // Store in cache
          pageCache.set(pageNum, canvas.cloneNode(true));
          
          // Replace placeholder content with canvas
          pageDiv.empty();
          pageDiv.removeClass('page-loading');
          pageDiv.append(canvas);
          
          // Mark page as loaded
          loadedPages.add(pageNum);
          
          // Update background loading indicator
          // updateBackgroundLoading(loadedPages.size, totalPagesCount);
          
          // Cleanup page to free memory
          page.cleanup();
          
          renderQueue.delete(pageNum);
          
          console.log(`Page ${pageNum} rendered successfully (cache size: ${pageCache.size})`);
          
          return true;
        } catch (error) {
          console.error(`Error rendering page ${pageNum}:`, error);
          pageDiv.html('<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #ff4444;"><p>Error loading page</p></div>');
          renderQueue.delete(pageNum);
          return false;
        }
      })();

      renderQueue.set(pageNum, renderPromise);
      return renderPromise;
    }

    // Load and render PDF with chunked loading
    async function loadPDF() {
      try {
        const loadingTask = pdfjsLib.getDocument({
          url: pdfPath,
          maxImageSize: isMobileDevice ? 1024 * 1024 : 4096 * 4096, // Limit image size on mobile
          cMapUrl: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/cmaps/',
          cMapPacked: true,
          disableAutoFetch: true, // Don't fetch all pages at once
          disableStream: false, // Enable streaming
          disableFontFace: isMobileDevice, // Disable custom fonts on mobile for speed
        });
        
        loadingTask.onProgress = function(progress) {
          if (progress.total > 0) {
            const percentage = Math.round((progress.loaded / progress.total) * 100);
            $('#loadingProgress').text(percentage + '%');
          }
        };
        
        pdfDocument = await loadingTask.promise;
        totalPagesCount = pdfDocument.numPages;
        
        console.log(`PDF loaded: ${totalPagesCount} pages (${(pdfDocument._pdfInfo.length / 1024 / 1024).toFixed(2)} MB)`);
        
        const flipbook = $('.flipbook');
        const lastHard = flipbook.find('.hard');
        
        // Create placeholders for all pages
        for (let pageNum = 1; pageNum <= totalPagesCount; pageNum++) {
          const pageDiv = createPlaceholderPage();
          pageDiv.attr('data-page-num', pageNum);
          pageDiv.insertBefore(lastHard);
        }
        
        initializeFlipbook();
        hideLoadingScreen();
        
        // Show background loading indicator
        $('#bgLoadingIndicator').fadeIn();
        
        // Only render first 2-4 pages initially (high priority)
        const initialPages = isMobileDevice ? 2 : 4;
        console.log(`Rendering initial ${initialPages} pages with high priority...`);
        
        for (let pageNum = 1; pageNum <= Math.min(initialPages, totalPagesCount); pageNum++) {
          const pageDiv = flipbook.find(`.page[data-page-num="${pageNum}"]`);
          await renderPage(pdfDocument, pageNum, pageDiv, true);
        }
        
        console.log('Initial pages loaded. Additional pages will load on demand.');
        
        // Load pages on demand when turning with intelligent preloading
        $(".flipbook").bind("turning", async function(event, page, view) {
          const pagesToLoad = [];
          
          // Clear old cache
          clearOldCache(page);
          
          // Current visible pages (highest priority)
          view.forEach(p => {
            if (p && !loadedPages.has(p) && !renderQueue.has(p)) {
              pagesToLoad.push({ page: p, priority: 10 });
            }
          });
          
          // Preload next 2 pages (medium priority)
          for (let i = 1; i <= 2; i++) {
            const nextPage = page + i;
            if (nextPage <= totalPagesCount && !loadedPages.has(nextPage) && !renderQueue.has(nextPage)) {
              pagesToLoad.push({ page: nextPage, priority: 5 });
            }
          }
          
          // Preload previous page (low priority)
          const prevPage = page - 1;
          if (prevPage >= 1 && !loadedPages.has(prevPage) && !renderQueue.has(prevPage)) {
            pagesToLoad.push({ page: prevPage, priority: 3 });
          }
          
          // Sort by priority
          pagesToLoad.sort((a, b) => b.priority - a.priority);
          
          // Load pages with delays between renders
          for (let { page: pageNum, priority } of pagesToLoad) {
            const pageDiv = flipbook.find(`.page[data-page-num="${pageNum}"]`);
            if (pageDiv.hasClass('page-loading')) {
              renderPage(pdfDocument, pageNum, pageDiv, priority > 8);
              // Add small delay between renders to prevent blocking
              if (priority < 10) {
                await new Promise(resolve => setTimeout(resolve, 100));
              }
            }
          }
        });
        
        // Trigger initial turning event to preload
        $(".flipbook").trigger("turning", [1, [1, 2]]);
        
      } catch (error) {
        console.error('Error loading PDF:', error);
        $('#loadingText').text('Error loading portfolio');
        $('#loadingProgress').text('Please refresh the page');
      }
    }

    function initializeFlipbook() {
      const originalWidth = 1188;
      const originalHeight = 840;
      const aspectRatio = originalWidth / originalHeight;
      
      const isMobile = window.innerWidth <= 768;
      const availableWidth = window.innerWidth - (isMobile ? 0 : 80);
      const availableHeight = window.innerHeight - (isMobile ? 80 : 100);
      
      let flipbookWidth, flipbookHeight;
      
      if (availableWidth / availableHeight > aspectRatio) {
        flipbookHeight = availableHeight;
        flipbookWidth = flipbookHeight * aspectRatio;
      } else {
        flipbookWidth = availableWidth;
        flipbookHeight = flipbookWidth / aspectRatio;
      }
      
      flipbookWidth = Math.min(flipbookWidth, originalWidth);
      flipbookHeight = Math.min(flipbookHeight, originalHeight);
      
      console.log('Initializing flipbook:', { 
        width: flipbookWidth, 
        height: flipbookHeight,
        isMobile: isMobile,
        isMobileDevice: isMobileDevice,
        renderQuality: RENDER_QUALITY
      });
      
      $(".flipbook").turn({
        width: flipbookWidth,
        height: flipbookHeight,
        autoCenter: true,
        acceleration: !isMobileDevice, // Disable acceleration on mobile
        gradients: !isMobileDevice, // Disable gradients on mobile for performance
        display: 'double',
        duration: isMobileDevice ? 400 : 600 // Faster animation on mobile
      });

      flipbookInitialized = true;

      $(".flipbook").bind("start", function() {
        isAnimating = true;
      });

      $(".flipbook").bind("end", function() {
        isAnimating = false;
      });

      $(document).keydown(function(e) {
        if (isAnimating) {
          e.preventDefault();
          return;
        }

        if (e.keyCode == 37) {
          $('#prevBtn').click();
          e.preventDefault();
        }
        
        if (e.keyCode == 39) {
          $('#nextBtn').click();
          e.preventDefault();
        }
      });

      $('#prevBtn').click(function() {
        if (isAnimating) return;

        var page = $(".flipbook").turn("page");
        if (page > 1) {
          isAnimating = true;
          if (!isMobileDevice) {
            $(".flipbook").turn("peel", "bl", true);
            setTimeout(function() {
              $(".flipbook").turn("previous");
            }, 40);
          } else {
            $(".flipbook").turn("previous");
          }
        }
      });

      $('#nextBtn').click(function() {
        if (isAnimating) return;

        var page = $(".flipbook").turn("page");
        var pages = $(".flipbook").turn("pages");
        if (page < pages) {
          isAnimating = true;
          if (!isMobileDevice) {
            $(".flipbook").turn("peel", "br", true);
            setTimeout(function() {
              $(".flipbook").turn("next");
            }, 40);
          } else {
            $(".flipbook").turn("next");
          }
        }
      });

      $(".flipbook").bind("turned", function(event, page, view) {
        if (page == 1) {
          $('#prevBtn').fadeOut();
        } else {
          $('#prevBtn').fadeIn();
        }

        if (page == $(".flipbook").turn("pages")) {
          $('#nextBtn').fadeOut();
        } else {
          $('#nextBtn').fadeIn();
        }
      });

      $('#prevBtn').hide();
      
      let resizeTimeout;
      $(window).on('resize orientationchange', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
          location.reload();
        }, 500);
      });
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
      if (pdfDocument) {
        pdfDocument.destroy();
      }
      pageCache.clear();
      renderQueue.clear();
    });

    $(document).ready(function() {
      loadPDF();
    });
  </script>

  <style>
    .bg-loading-indicator {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 9999;
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .bg-loader {
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .page-loading {
      background: #f5f5f5;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .nav-arrow.animating {
      pointer-events: none;
      opacity: 0.5;
    }
  </style>
</body>

</html>